# SICP Exercise 1.14: Coin change recursion tree

Draw the tree illustrating the process generated by the `count-change`
procedure of 1.2.2 in making change for 11 cents.  What are the orders of
growth of the space and number of steps used by this process as the amount to
be changed increases?

## Answer

First,
let us restate the change counting problem and its solution, as given in section 1.2.2.

"In how many different ways can one change a given amount of money, 
given a list of denominations?"

The solution is defined recursively.
The number of ways to change the given amount of money using *n* kinds of coins
is equal to the sum of:

* The number of ways to change the given amount using all kinds of coins except the first one.
* The number of ways to change the given amount minus the first denomination using *n* kinds of coins.

Eventually the problem is reduced to some degenerate cases:

* In how many ways can an amount of 0 be changed? Is it zero or one? While not entirely obvious, this must be 1.
* In how many ways can a positive amount be changed without using any coins? I would say 0, since this woul be nonsensical.
* In how many ways can a negative amount be changed? Nonsensical, so 0.

Scheme code given by SICP:

    (define (count-change amount)
      (cc amount 5))

    (define (cc amount kinds-of-coins)
      (cond ((= amount 0) 1)
            ((or (< amount 0) 
                (= kinds-of-coins 0)) 
            0)
            (else 
            (+ (cc amount (- kinds-of-coins 1))
                (cc (- amount (first-denomination 
                              kinds-of-coins))
                    kinds-of-coins)))))

    (define (first-denomination kinds-of-coins)
      (cond ((= kinds-of-coins 1) 1)
            ((= kinds-of-coins 2) 5)
            ((= kinds-of-coins 3) 10)
            ((= kinds-of-coins 4) 25)
            ((= kinds-of-coins 5) 50)))

**Recursion tree for *(count-change 11)***

    (count-change 11) = 4
      (cc 11 5) = 4
        (cc -39 5) = 0
        (cc 11 4) = 4
          (cc -14 5) = 0
          (cc 11 3) = 4
            (cc 1 3) = 1
              (cc -9 3) = 0
              (cc 1 2) = 1
                (cc -4 2) = 0
                (cc 1 1) = 1
                  (cc 0 1) = 1
                  (cc 1 0) = 0
            (cc 11 2) = 3
              (cc 6 2) = 2
                (cc 1 2) = 1
                  (cc -4 2) = 0
                  (cc 1 1) = 1
                    (cc 0 1) = 1
                (cc 6 1) = 1
                  (cc 5 1) = 1
                    (cc 4 1) = 1
                      (cc 3 1) = 1
                        (cc 2 1) = 1
                          (cc 1 1) = 1
                            (cc 0 1) = 1
              (cc 11 1) = 1
                (cc 10 1) = 1
                  (cc 9 1) = 1
                    (cc 8 1) = 1
                      (cc 7 1) = 1
                        (cc 6 1) = 1
                          (cc 5 1) = 1
                            (cc 4 1) = 1
                              (cc 3 1) = 1
                                (cc 2 1) = 1
                                  (cc 1 1) = 1
                                    (cc 0 1) = 1

Space required is O(n) 
(to store the deepest recursion, since function isn't using tail calls).
Not sure about the runtime complexity since I'm
not in the mood for complexity analysis right now.
        
For some wonderful tree visualizations check out 
[the Scheme Wiki](http://community.schemewiki.org/?sicp-ex-1.14)
as always.